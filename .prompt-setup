# Inspired by the M365 Princess theme usually available on Oh-My-ZSH
# Enable command substitution in prompt
setopt PROMPT_SUBST

# Symbols
typeset -A symbol_list=(
    [powerline]=$'\ue0b0'
    [heart]=$'\u2764'
    [arrow]=$'\u279c'
    [star]=$'\u2605'
    [stash]=$'\ueb4b'
    [node]=$'\ue718'
    [round_left]=$'\ue0b6'
    [round_right]=$'\ue0b4'
    [folder]=$'\uf07c'
    [git]=$'\ue725'
    [open_folder]=$'\uF115'
    [rust]=$'\ue7a8'
)

# Colors
typeset -A colors
if [[ "$COLORTERM" == "truecolor" ]] || [[ "$TERM" == *"24bit"* ]]; then
    colors=(
        [white]='#FFFFFF'
        [one]='#D52D00'
        [two]='#EF7627'
        [three]='#FF9A56'
        [four]='#D162A4'
        [five]='#B55690'
        [six]='#A30262'
    )
else
    colors=(
        [white]='255'
        [one]='160'
        [two]='208'
        [three]='215'
        [four]='169'
        [five]='132'
        [six]='125'
    )
fi


# segment helper
wrap_segment() {
    local -a segment
    local start=$1 # is this the start of the line "true or false"
    local segment_color=$2 # the color for this segment main color passed in as hex
    local content=$3 # segment content

    segment="%f"
    if [[ $start == "true" ]]; then
        segment+="%F{$segment_color}$symbol_list[round_left]"
    else
        segment+="%k%F%K{$segment_color}${symbol_list[powerline]}"
    fi
    segment+="%K{$segment_color}%F{$colors[white]} $content %k%F{$segment_color}${symbol_list[powerline]}"
    
    echo $segment
}

git_info() {
    local ref
    ref=$(command git symbolic-ref HEAD 2> /dev/null) || \
    ref=$(command git rev-parse --short HEAD 2> /dev/null) || return 0
    echo " ${symbol_list[arrow]} (${ref#refs/heads/}$(git_stash_count)) ${symbol_list[git]}"
}

git_stash_count() {
    local stash_count
    stash_count=$(git stash list 2>/dev/null | wc -l | tr -d ' ')
    [[ "$stash_count" -gt 0 ]] && echo " ${symbol_list[stash]} ${stash_count}"
}

is_git_repo() {
    git rev-parse --is-inside-work-tree &> /dev/null
}

get_rust_version() {
    local rust_version
    rust_version=$(rustc --version 2> /dev/null)
    if [[ $? -eq 0 ]]; then
        echo "${symbol_list[rust]} v${rust_version#* }"
    else
        echo "${symbol_list[rust]} unavailable"
    fi
}

get_node_version() {
    local node_version
    node_version=$(node -v 2> /dev/null)
    if [[ $? -eq 0 ]]; then
        echo "${symbol_list[node]} v${node_version#*v}"
    else
        echo "${symbol_list[node]} unavailable"
    fi
}

# Project info segment function
project_info() {
    if [ -f "Cargo.toml" ]; then
        get_rust_version
    fi

    if [ -f "package.json" ]; then
        get_node_version
    fi
}

path_info() {
    if is_git_repo; then
        echo "$(basename $(git rev-parse --show-toplevel))"
    else
        echo "%~"
    fi
}

function build_info_line() {
    local -a segments
    local -a basedir
    local -a pathInfo
    basedir=$(basename $(pwd))   
    pathInfo=$(path_info)

    segments+="$(wrap_segment "true" "${colors[one]}" ${(%):-%n})"
    
    segments+="$(wrap_segment "false" "${colors[two]}" "repo: $pathInfo")"

    if is_git_repo ; then
        segments+="$(wrap_segment "false" "${colors[three]}" "$(git_info)")"
    fi
    if is_git_repo && [[ "$basedir" != "$pathInfo" ]] ; then
        segments+="$(wrap_segment "false" "${colors[four]}" "%~")"
    fi
    if is_git_repo && [[ "$basedir" == "$pathInfo" ]] ; then
        segments+="$(wrap_segment "false" "${colors[five]}" "$(project_info)")"
    fi
    echo "${(j::)segments}"
}

precmd() {
    print -P "\n$(build_info_line)\n"
}

PROMPT=" ${symbol_list[heart]} $(date '+%H:%M') |>"
