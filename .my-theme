# Inspired by the M365 Princess theme usually available on Oh-My-ZSH
# Enable command substitution in prompt
setopt PROMPT_SUBST

# Symbols
typeset -A symbols=(
    [powerline]=$'\ue0b0'
    [heart]=$'\u2764'
    [arrow]=$'\u279c'
    [stash]=$'\ueb4b'
    [node]=$'\ue718'
    [round_left]=$'\ue0b6'
    [round_right]=$'\ue0b4'
    [folder]=$'\uf07c'
    [git]=$'\ue725'
    [open_folder]=$'\uF115'
    [rust]=$'\ue7a8'
)

# Colors
typeset -A colors
if [[ "$COLORTERM" == "truecolor" ]] || [[ "$TERM" == *"24bit"* ]]; then
    colors=(
        [white]='#FFFFFF'
        [one]='#D52D00'
        [two]='#EF7627'
        [three]='#FF9A56'
        [four]='#D162A4'
        [five]='#B55690'
        [six]='#A30262'
    )
else
    colors=(
        [white]='255'
        [one]='160'
        [two]='208'
        [three]='215'
        [four]='169'
        [five]='132'
        [six]='125'
    )
fi

# Segment builder
segment() {
    local bg="$1" fg="${2:-${colors[white]}}" content="$3"
    echo "%K{${colors[$bg]}}%F{$fg} $content %k%f${symbols[powerline]}"
}

# Git segment function
git_info() {
    local ref
    ref=$(command git symbolic-ref HEAD 2> /dev/null) || \
    ref=$(command git rev-parse --short HEAD 2> /dev/null) || return 0
    echo " ${symbols[arrow]} (${ref#refs/heads/}$(git_stash_count)) ${symbols[git]}"
}

git_stash_count() {
    local stash_count
    stash_count=$(git stash list 2>/dev/null | wc -l | tr -d ' ')
    [[ "$stash_count" -gt 0 ]] && echo " ${symbols[stash]} ${stash_count}"
}

# Project info segment function
project_info() {
    # Check if in git repo first
    if git rev-parse --is-inside-work-tree &> /dev/null; then
        # In git repo, check for specific project files
        if [ -f "Cargo.toml" ]; then
            command -v rustc &> /dev/null && echo "${symbols[rust]} v$(rustc --version | cut -d ' ' -f 2)" || echo "${symbols[rust]} unavailable"
            return
        elif [ -f "package.json" ]; then
            command -v node &> /dev/null && echo "${symbols[node]} $(node -v)" || echo "${symbols[node]} unavailable"
            return
        else
            echo "${symbols[arrow]} ${symbols[open_folder]}"
            return
        fi
    fi
    
    # Not in git repo
    echo "local ${symbols[folder]}"
}

# Time segment function
time_info() {
    echo " ${symbols[heart]} $(date '+%H:%M') "
}

path_info() {
    echo " ${symbols[folder]} %~ "
}

# Add new function to check if in git repo
is_git_repo() {
    git rev-parse --is-inside-work-tree &> /dev/null
}

# Conditional git segment
git_segment() {
    if is_git_repo; then
        echo "%{%K{${colors[three]}}%F{${colors[two]}}%}${symbols[powerline]}%{%F{${colors[white]}}%}$(git_info) %{%K{${colors[four]}}%F{${colors[three]}}%}"
    else
        echo "%{%K{${colors[four]}}%F{${colors[two]}}%}"
    fi
}

build_info_line() {
    # Initialize array to store prompt segments
    local -a segments

    # Username segment with leading rounded edge
    segments+=("%{%k%F{${colors[one]}}%}${symbols[round_left]}%{%K{${colors[one]}}%F{${colors[white]}}%}%n ")

    # Directory segment
    segments+=("%{%K{${colors[two]}}%F{${colors[one]}}%}${symbols[powerline]}%{%F{${colors[white]}}%} %~ ")

    # Git information segment (conditional)
    segments+=("$(git_segment)${symbols[powerline]}")

    # Project information segment
    segments+=("%{%K{${colors[four]}}%F{${colors[white]}}%} $(project_info) ")

    # Time segment with ending rounded edge
    segments+=("%{%K{${colors[five]}}%F{${colors[four]}}%}${symbols[powerline]}%{%F{${colors[white]}}%}$(time_info)%{%k%F{${colors[five]}}%}${symbols[round_right]}")

    # Join all segments and output
    echo $'\n'"${(j::)segments}"
}

precmd() {
    print -P "$(build_info_line)"
}

PROMPT=$'\n'"|> "

